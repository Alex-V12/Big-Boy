# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt



G = nx.DiGraph()
G.add_weighted_edges_from([
    ('s',1,16), ('s',2,13),
    (1,3,12), (2,1,4), (2,4,14), (3,2,9), (4,3,7),
    (3,5,20), (4,5,4),(5,6,9),
    (6,'t',20), (4,'t',4)])

layers = [['s'],[1,2],[3,4],[5,6],['t']]
Pos = {}
for i, layer in enumerate(layers):
    n = len(layers)
    for j, node in enumerate(layer):
        Pos[node] = (i,-j)

nx.draw(G,Pos, with_labels=True,  arrows = 'True')


# CHECKERS 

def is_input_correct(G,s,t):
    
    if isinstance(G,nx.DiGraph) == False:
        raise ValueError("Not a directed graph")
        
    if s not in list(G.nodes()):
        raise ValueError("s Is not an element in V(G)")
        
    if t not in list(G.nodes()):
        raise ValueError("t Is not an element in V(G)")   
        
    if t == s:
        raise ValueError("Source and Sink must be distinct") 
        
    if nx.is_weakly_connected(G) == False:
        raise ValueError("G is not weakly connected")
    
    else:
        print("Input is correct")        


inf = float('inf')

def Find_path(G,s,t):

    vis = ['s']
    un_vis = list(G.nodes)
    un_vis.remove('s')
    
    table = dict()
    Weights = nx.get_edge_attributes(G,'weight')
    
    for i in list(G.nodes):
        table[i] = [0,[]]
        
    table['s'] = [inf,['s']]
        
    while vis != list(G.nodes):
        Max_cap = 0
        Max_node = None
        for i in vis:
            if Max_cap < Weights[i]:
                Max_cap = Weights[i]
                Max_node = i 
                
        neighbours = list(G.neighbors[Max_node])
        for i in neighbours:
            if min[Weights[Max_node],Weights[Max_node,i]]>Weights[i]:
                table[i] = [min[Weights[Max_node],Weights[Max_node,i]],table[i][1].append(i)]
        
                
        for i in un_vis:
            
        
    
    


def Solve(G,s,t):
    if is_input_correct(G,s,t) != "Input is correct" :
        return is_input_correct(G,s,t)
