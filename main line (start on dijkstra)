# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt



G = nx.DiGraph()
G.add_weighted_edges_from([
    ('s',1,16), ('s',2,13),
    (1,3,12), (2,1,4), (2,4,14), (3,2,9), (4,3,7),
    (3,5,20), (4,5,4),(5,6,9),
    (6,'t',20), (4,'t',4)])

layers = [['s'],[1,2],[3,4],[5,6],['t']]
Pos = {}
for i, layer in enumerate(layers):
    n = len(layers)
    for j, node in enumerate(layer):
        Pos[node] = (i,-j)

nx.draw(G,Pos, with_labels=True,  arrows = True)


# CHECKERS 

def is_input_correct(G,s,t):
    
    if isinstance(G,nx.DiGraph) == False:
        raise ValueError("Not a directed graph")
        
    if s not in list(G.nodes()):
        raise ValueError("s Is not an element in V(G)")
        
    if t not in list(G.nodes()):
        raise ValueError("t Is not an element in V(G)")   
        
    if t == s:
        raise ValueError("Source and Sink must be distinct") 
        
    if nx.is_weakly_connected(G) == False:
        raise ValueError("G is not weakly connected")
    
    else:
        print("Input is correct")        


inf = float('inf')

def Find_path(G,s,t):

    vis = ['s']
    un_vis = list(G.nodes)
    un_vis.remove('s')
    
    table = dict()
    Weights = nx.get_edge_attributes(G,'weight')
    
    for i in list(G.nodes):
        table[i] = [0,[]]
        
    table['s'] = [inf,['s']]
        

    while vis != list(G.nodes):
        Max_node = [0,[None]]
        for i in vis:
            if Max_node[0] < table[i][0]:
                Max_node = i
        if Max_node[0] == 0:
          break 

                
        neighbours = list(G.neighbors(Max_node))
        for i in neighbours:
            a = table[Max_node][0]
            b = Weights[Max_node,i] 
            print(a,b)
            if min(table[Max_node][0],Weights[Max_node,i]) >= table[i][0]:
                table[i] = [min(table[Max_node][0],Weights[Max_node,i]),table[i][1].append(i)]
        
        new_node = [0,[None]]        
        for i in un_vis:
          print(new_node[0])
          print(table[i][0])
          if new_node[0] <= table[i][0]:
            new_node = table[i]
            
        vis.append(new_node)
        un_vis.remove(new_node)

            



Find_path(G,'s','t')



#def Solve(G,s,t):
#    if is_input_correct(G,s,t) != "Input is correct" :
#        return is_input_correct(G,s,t)
