# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt



G = nx.DiGraph()
G.add_weighted_edges_from([
    ('s',1,16),('s',2,13),
    (1,3,12),(2,1,4),(2,4,14),(3,2,9),(4,3,7),
    (3,5,20),(4,5,4),(5,6,9),
    (6,'t',20),(4,6,4),(5,'t',20)])

layers = [['s'],[1,2],[3,4],[5,6],['t']]
Pos = {}
for i, layer in enumerate(layers):
    n = len(layers)
    for j, node in enumerate(layer):
        Pos[node] = (i,-j)

nx.draw(G,Pos, with_labels=True,  arrows = True)


# CHECKERS 

def is_input_correct(G,s,t):
    
    if isinstance(G,nx.DiGraph) == False:
        raise ValueError("Not a directed graph")
        
    if s not in list(G.nodes()):
        raise ValueError("s Is not an element in V(G)")
        
    if t not in list(G.nodes()):
        raise ValueError("t Is not an element in V(G)")   
        
    if t == s:
        raise ValueError("Source and Sink must be distinct") 
        
    if nx.is_weakly_connected(G) == False:
        raise ValueError("G is not weakly connected")
    
    else:
        print("Input is correct")        


inf = float('inf')

def Find_Mpath(G,s,t):

    vis = ['s']
    un_vis = list(G.nodes)
    un_vis.remove('s')

    table = dict()
    Weights = nx.get_edge_attributes(G,'weight')
    
    for i in list(G.nodes):
        table[i] = [0,[]]
        
    table['s'] = [inf,['s']]
        

    while un_vis != list(G.nodes):
        Max_node = [0,[None]]
        for i in vis:
            if Max_node[0] <= table[i][0]:
                Max_name = i
                Max_node = table[i]
        if Max_node[0] == 0:
          break 

        print(Max_name)
    #    print(Max_node)
        
        neighbours = list(G.neighbors(Max_name))
        for i in neighbours:
            if min(Max_node[0],Weights[Max_name,i]) >= table[i][0]:
                path = Max_node[1]
                table[i] = [min(table[Max_name][0],Weights[Max_name,i]), path+[i]]

        new_node = [0,None]        
        for i in un_vis:
          if new_node[0] < table[i][0]:
            new_node = table[i]
            node_name = i

        print(node_name)
        print(un_vis)
        vis.append(node_name)

        print(table)   

        for i in vis:
          if set(G.neighbors(i)) in set(vis):
            vis.append(i)
            un_vis.remove(i) 

Find_Mpath(G,'s','t')



#def Solve(G,s,t):
#    if is_input_correct(G,s,t) != "Input is correct" :
#        return is_input_correct(G,s,t)
