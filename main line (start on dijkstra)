# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
inf = float('inf')


G = nx.DiGraph()
G.add_weighted_edges_from([
    ('s',1,16),('s',2,13),
    (1,3,12),(2,1,4),(2,4,14),(3,2,9),(4,3,7),
    (3,5,20),(4,5,4),(5,6,9),
    (6,'t',20),(4,6,4),(5,'t',20)])

layers = [['s'],[1,2],[3,4],[5,6],['t']]
Pos = {}
for i, layer in enumerate(layers):
    n = len(layers)
    for j, node in enumerate(layer):
        Pos[node] = (i,-j)

nx.draw(G,Pos, with_labels=True,  arrows = True)



# CHECKERS 

def is_input_correct(G,s,t):
    
    if isinstance(G,nx.DiGraph) == False:
        raise ValueError("Not a directed graph")
        
    if s not in list(G.nodes()):
        raise ValueError("Source is not an element in V(G)")
        
    if t not in list(G.nodes()):
        raise ValueError("Sink is not an element in V(G)")   
        
    if t == s:
        raise ValueError("Source and Sink must be distinct") 
    
    else:
        print("Input is correct")
        return True        


# Finding Augmenting path 


def Find_Max_Path(G,s,t):

    vis = [s]

    table = dict()                               # Creating a dictionary of the graph with additional attributes 
    Weights = nx.get_edge_attributes(G,'weight') # Helpful having a dictionary of weights  
    for i in list(G.nodes):
        table[i] = [0,[]]
    table[s] = [inf,[s]]

    for n in range(len(list(G.nodes))):
      edges = []                            # list of all edges from vis_nodes ----> nodes 
      for i in vis:
        neighbours = list(G.neighbors(i))
        for j in neighbours:
          if j not in vis:
            edges += [[i,j]]

      cap = 0
      for i in edges:
        if cap < Weights[i[0],i[1]]:
          cap = Weights[i[0],i[1]]
          Max_edge = i
          v = Max_edge[0]
          w = Max_edge[1]
      
      table[w] = [min(table[v][0],Weights[v,w]),table[v][1]+[w]]
      vis.append(w)

      if table[t][0] != 0:
        return table[t]          # Returing [Capacity of path,[path]]

    return table    # When no augmenting path has been found  


def Find_Max_flow(G,Source,Sink):
    
  F = nx.DiGraph()    # Flow fraph   
  Max_flow = 0
  s = Source
  t = Sink
  
  if is_input_correct(G,s,t) != True:
    return None
  else:
      
    R = G.copy()    # Residule Graph 
    for (u,v) in G.edges():
      R.add_edge(v,u,weight = 0) 

    # Weights = nx.get_edge_attributes(G,'weight')
    # print(Weights)
    # print('cahnge')
    # print(nx.get_edge_attributes(R,'weight'))
        
    
    while type(Find_Max_Path(R,s,t)) == list:
    #for i in range(2):
      A_path = Find_Max_Path(R,s,t)
      Max_flow += A_path[0]
          
      
      for i in range(len(A_path[1])-1):
          v = A_path[1][i]
          w = A_path[1][i+1]
          R[v][w]['weight'] -= A_path[0] 
          R[w][v]['weight'] += A_path[0]
          F.add_edge(v,w,weight = A_path[0])    
              
              
      # print(nx.get_edge_attributes(R,'weight'))
      # print(Max_flow)        
       
    if type(Find_Max_Path(R,s,t)) == dict:
      Min_cut = []
      for i in Find_Max_Path(R,s,t):
        if Find_Max_Path(R,s,t)[i][1] != []:
          Min_cut.append(i)
      nx.draw(F,Pos, with_labels=True,  arrows = True)    
      return [ Max_flow , Min_cut ]
  

Find_Max_flow(G,'s','t')
